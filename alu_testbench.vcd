$date
	Tue Nov 12 17:39:42 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module alu_testbench $end
$var wire 32 ! newpc [31:0] $end
$var wire 1 " branchTaken $end
$var wire 32 # aluOut [31:0] $end
$var parameter 32 $ WORD_SIZE $end
$var reg 32 % aluIn1 [31:0] $end
$var reg 32 & aluIn2 [31:0] $end
$var reg 3 ' funct3 [2:0] $end
$var reg 7 ( funct7 [6:0] $end
$var reg 32 ) immediate [31:0] $end
$var reg 7 * opcode [6:0] $end
$var reg 32 + pc [31:0] $end
$var integer 32 , svut_critical [31:0] $end
$var integer 32 - svut_error [31:0] $end
$var integer 32 . svut_error_total [31:0] $end
$var integer 32 / svut_nb_test [31:0] $end
$var integer 32 0 svut_nb_test_success [31:0] $end
$var integer 32 1 svut_status [31:0] $end
$var integer 32 2 svut_test_number [31:0] $end
$var integer 32 3 svut_warning [31:0] $end
$scope module dut $end
$var wire 32 4 PC [31:0] $end
$var wire 3 5 funct3 [2:0] $end
$var wire 7 6 funct7 [6:0] $end
$var wire 32 7 immediate [31:0] $end
$var wire 7 8 opcode [6:0] $end
$var wire 32 9 operand1 [31:0] $end
$var wire 32 : operand2 [31:0] $end
$var reg 32 ; alu_out [31:0] $end
$var reg 1 " branch_taken $end
$var reg 32 < out_PC [31:0] $end
$upscope $end
$scope task run $end
$var reg 1 = msg $end
$upscope $end
$scope task setup $end
$var reg 1 > msg $end
$upscope $end
$scope task teardown $end
$var reg 1 ? msg $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 $
$end
#0
$dumpvars
x?
0>
0=
bx <
b11110 ;
b111 :
b10111 9
b110011 8
bx 7
b0 6
b0 5
bx 4
b0 3
b0 2
b0 1
b0 0
b1 /
b0 .
b0 -
b0 ,
bx +
b110011 *
bx )
b0 (
b0 '
b111 &
b10111 %
b11110 #
x"
bx !
$end
#4
b10 #
b10 ;
b10 &
b10 :
b100 %
b100 9
b100000 (
b100000 6
b10 /
b1 2
b1 0
0?
#8
b11011 #
b11011 ;
b10010 &
b10010 :
b1011 %
b1011 9
b110 '
b110 5
b0 (
b0 6
b11 /
b10 2
b10 0
#12
b1 #
b1 ;
b0 &
b0 :
b1 %
b1 9
b100 /
b11 2
b11 0
#16
b10 #
b10 ;
b1110 &
b1110 :
b10010 %
b10010 9
b111 '
b111 5
b101 /
b100 2
b100 0
#20
b1 #
b1 ;
0"
b0 '
b0 5
b11 &
b11 :
b100 %
b100 9
b1100011 *
b1100011 8
b110 /
b101 2
b101 0
#24
b0 #
b0 ;
1"
b111001100 !
b111001100 <
b111100 )
b111100 7
b100 &
b100 :
b110010000 +
b110010000 4
b111 /
b110 2
b110 0
#28
0"
b10 '
b10 5
b1000 /
b111 2
b111 0
#32
b1 #
b1 ;
1"
b101 '
b101 5
b101 %
b101 9
b1001 /
b1000 2
b1000 0
#36
b11111111111111111111111111111111 #
b11111111111111111111111111111111 ;
b100 '
b100 5
b11 %
b11 9
b1010 /
b1001 2
b1001 0
#40
b0 &
b0 :
b10010 %
b10010 9
b1101111 *
b1101111 8
b1011 /
b1010 2
b1010 0
#44
b1111110 #
b1111110 ;
b11 &
b11 :
b101010 %
b101010 9
b1 (
b1 6
b110011 *
b110011 8
b1100 /
b1011 2
b1011 0
#48
b11111111111111111111111110000010 #
b11111111111111111111111110000010 ;
b11111111111111111111111111111101 &
b11111111111111111111111111111101 :
b1101 /
b1100 2
b1100 0
#52
b1010 #
b1010 ;
b110010011 !
b110010011 <
b11 )
b11 7
b111 %
b111 9
b0 '
b0 5
b10011 *
b10011 8
b1110 /
b1101 2
b1101 0
#56
b110010 #
b110010 ;
b110010 !
b110010 <
b1000 )
b1000 7
b101010 +
b101010 4
b10111 *
b10111 8
b1111 /
b1110 2
b1110 0
#60
b100 #
b100 ;
b10 &
b10 :
b1 %
b1 9
b1 '
b1 5
b10011 *
b10011 8
b10000 /
b1111 2
b1111 0
#64
b10 #
b10 ;
b1000 %
b1000 9
b101 '
b101 5
b10001 /
b10000 2
b10000 0
#68
b1 #
b1 ;
b101011 !
b101011 <
b1 )
b1 7
b110111 *
b110111 8
b10010 /
b10001 2
b10001 0
#72
b10010 2
b10010 0
